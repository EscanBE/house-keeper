package config

import (
	"fmt"
	"github.com/EscanBE/go-ienumerable/goe"
	libutils "github.com/EscanBE/go-lib/utils"
	"github.com/EscanBE/house-keeper/cmd/utils"
	"github.com/EscanBE/house-keeper/constants"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"os"
	"regexp"
	"strings"
)

const (
	flagTsvInputFilePath            = "tsv-input"
	flagSshConfigOutputFilePath     = "output-file"
	flagOverrideSshConfigOutputFile = "override"
	flagSshKeyPathRoot              = "key-root"
	flagSshKeyPathUser              = "key-user"

	tsvLineFormat = "Host<tab>HostName<tab>User"
)

var tsvInputFilePath, sshConfigOutputFilePath, sshKeyPathRoot, sshKeyPathUser string
var overrideSshConfigOutputFile bool

// ConfigureSshCommands registers a sub-tree of commands
func ConfigureSshCommands() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "ssh",
		Short: "Configure ~/.ssh/config file",
		Args:  cobra.NoArgs,
		Run:   configureSshConfigFile,
	}

	utils.AddFlagWorkingDir(cmd)

	cmd.PersistentFlags().StringVar(
		&tsvInputFilePath,
		flagTsvInputFilePath,
		"",
		fmt.Sprintf("input tsv file, each line format: %s", tsvLineFormat),
	)

	cmd.PersistentFlags().StringVar(
		&sshConfigOutputFilePath,
		flagSshConfigOutputFilePath,
		fmt.Sprintf("%s_generated_ssh_config", constants.BINARY_NAME),
		"output SSH config file",
	)

	cmd.PersistentFlags().BoolVar(
		&overrideSshConfigOutputFile,
		flagOverrideSshConfigOutputFile,
		false,
		"override output SSH config file if exists",
	)

	cmd.PersistentFlags().StringVar(
		&sshKeyPathRoot,
		flagSshKeyPathRoot,
		"",
		"SSH key file path to be used for root users",
	)

	cmd.PersistentFlags().StringVar(
		&sshKeyPathUser,
		flagSshKeyPathUser,
		"",
		"SSH key file path to be used for non-root users",
	)

	return cmd
}

var regexReplaceContinousSpace = regexp.MustCompile("[\\s\\t]+")

func configureSshConfigFile(_ *cobra.Command, _ []string) {
	if libutils.IsBlank(tsvInputFilePath) {
		panic(fmt.Errorf("input TSV is required by supplying mandatory flag --%s", flagTsvInputFilePath))
	}

	if !isFileExists(tsvInputFilePath) {
		panic(fmt.Errorf("mandatory input TSV file %s provided flag --%s does not exists", tsvInputFilePath, flagTsvInputFilePath))
	}

	if libutils.IsBlank(sshConfigOutputFilePath) {
		panic(fmt.Errorf("output SSH config file is required by supplying mandatory flag --%s", flagSshConfigOutputFilePath))
	}

	if isFileExists(sshConfigOutputFilePath) {
		if !overrideSshConfigOutputFile {
			panic(fmt.Errorf("output SSH config file %s provided flag --%s is already exists, if you want to override, supply --%s flag", sshConfigOutputFilePath, flagSshConfigOutputFilePath, flagOverrideSshConfigOutputFile))
		}
	}

	if libutils.IsBlank(sshKeyPathRoot) {
		panic(fmt.Errorf("SSH key for root user is required by supplying mandatory flag --%s", flagSshKeyPathRoot))
	}

	if !isFileExists(sshKeyPathRoot) {
		panic(fmt.Sprintf("SSH key (for root user) could not be found: %s", sshKeyPathRoot))
	}

	if libutils.IsBlank(sshKeyPathUser) {
		panic(fmt.Errorf("SSH key for non-root user is required by supplying mandatory flag --%s", flagSshKeyPathUser))
	}

	if !isFileExists(sshKeyPathUser) {
		panic(fmt.Sprintf("SSH key (for non-root user) could not be found: %s", sshKeyPathUser))
	}

	sshConfigContent := "# Generated by House Keeper\n"

	bz, err := os.ReadFile(tsvInputFilePath)
	if err != nil {
		panic(errors.Wrap(err, fmt.Sprintf("failed to read %s", tsvInputFilePath)))
	}
	tsvLines := goe.NewIEnumerable(strings.Split(string(bz), "\n")...).Select(func(line string) any {
		return strings.TrimSpace(line)
	}).CastString()
	if !tsvLines.Any() {
		panic(fmt.Errorf("input TSV %s is empty", tsvInputFilePath))
	}
	hostTracker := make(map[string]bool)
	for _, line := range tsvLines.ToArray() {
		spl := strings.SplitN(
			regexReplaceContinousSpace.ReplaceAllString(strings.Replace(line, "\t", " ", -1), " "),
			" ", 3,
		)
		if len(spl) != 3 {
			panic(fmt.Sprintf("in input tsv file, each line must maintains format: %s", tsvLineFormat))
		}

		host := strings.TrimSpace(spl[0])
		hostName := strings.TrimSpace(spl[1])
		user := strings.TrimSpace(spl[2])

		if len(host) < 1 {
			panic(fmt.Sprintf("SSH config host must not be empty at line: %s", line))
		}
		normalizedHost := strings.ToLower(host)
		if _, found := hostTracker[normalizedHost]; found {
			panic(fmt.Sprintf("SSH config host does not unique at line: %s", line))
		}
		hostTracker[normalizedHost] = true
		if len(hostName) < 1 {
			panic(fmt.Sprintf("SSH config host name must not be empty at line: %s", line))
		}
		if len(user) < 1 {
			panic(fmt.Sprintf("SSH config user must not be empty at line: %s", line))
		}

		sshConfigContent += fmt.Sprintf(`
Host %s
    HostName %s
    User %s
    IdentityFile %s
`, host, hostName, user, libutils.ConditionalString(strings.EqualFold(user, "root"), sshKeyPathRoot, sshKeyPathUser))

	}

	err = os.WriteFile(sshConfigOutputFilePath, []byte(sshConfigContent), 0o644)
	if err != nil {
		panic(errors.Wrap(err, "failed to write output SSH config file"))
	}
}
