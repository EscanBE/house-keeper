package config

import (
	"fmt"
	"github.com/EscanBE/go-ienumerable/goe"
	libutils "github.com/EscanBE/go-lib/utils"
	"github.com/EscanBE/house-keeper/cmd/utils"
	"github.com/EscanBE/house-keeper/constants"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"os"
	"regexp"
	"strings"
)

const (
	flagTsvInputFilePath            = "tsv-input"
	flagSshConfigOutputFilePath     = "output-file"
	flagOverrideSshConfigOutputFile = "override"
	flagSshKeyPathRoot              = "key-root"
	flagSshKeyPathUser              = "key-user"
	flagSshKeyPathPerUser           = "key-per-user"

	tsvLineFormat = "Host<tab>HostName<tab>User(<tab># Optional comment)"
)

var tsvInputFilePath, sshConfigOutputFilePath, sshKeyPathRoot, sshKeyPathUser string
var overrideSshConfigOutputFile bool
var sshKeyPathPerUser []string

// ConfigureSshCommands registers a sub-tree of commands
func ConfigureSshCommands() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "ssh",
		Short: "Configure ~/.ssh/config file",
		Args:  cobra.NoArgs,
		Run:   configureSshConfigFile,
	}

	utils.AddFlagWorkingDir(cmd)

	cmd.PersistentFlags().StringVar(
		&tsvInputFilePath,
		flagTsvInputFilePath,
		"",
		fmt.Sprintf("input tsv file, each line format: %s", tsvLineFormat),
	)

	cmd.PersistentFlags().StringVar(
		&sshConfigOutputFilePath,
		flagSshConfigOutputFilePath,
		fmt.Sprintf("%s_generated_ssh_config", constants.BINARY_NAME),
		"output SSH config file",
	)

	cmd.PersistentFlags().BoolVar(
		&overrideSshConfigOutputFile,
		flagOverrideSshConfigOutputFile,
		false,
		"override output SSH config file if exists",
	)

	cmd.PersistentFlags().StringVar(
		&sshKeyPathRoot,
		flagSshKeyPathRoot,
		"",
		"SSH key file path to be used for root users",
	)

	cmd.PersistentFlags().StringVar(
		&sshKeyPathUser,
		flagSshKeyPathUser,
		"",
		"SSH key file path to be used for non-root users (fallback)",
	)

	cmd.PersistentFlags().StringSliceVar(
		&sshKeyPathPerUser,
		flagSshKeyPathPerUser,
		[]string{},
		"SSH key file path to be used for each non-root user (format: user1,path1,user2,path2)",
	)

	return cmd
}

var regexReplaceContinousSpace = regexp.MustCompile("[\\s\\t]+")

func configureSshConfigFile(_ *cobra.Command, _ []string) {
	if libutils.IsBlank(tsvInputFilePath) {
		panic(fmt.Errorf("input TSV is required by supplying mandatory flag --%s", flagTsvInputFilePath))
	}

	if !isFileExists(tsvInputFilePath) {
		panic(fmt.Errorf("mandatory input TSV file %s provided flag --%s does not exists", tsvInputFilePath, flagTsvInputFilePath))
	}

	if libutils.IsBlank(sshConfigOutputFilePath) {
		panic(fmt.Errorf("output SSH config file is required by supplying mandatory flag --%s", flagSshConfigOutputFilePath))
	}

	if isFileExists(sshConfigOutputFilePath) {
		if !overrideSshConfigOutputFile {
			panic(fmt.Errorf("output SSH config file %s provided flag --%s is already exists, if you want to override, supply --%s flag", sshConfigOutputFilePath, flagSshConfigOutputFilePath, flagOverrideSshConfigOutputFile))
		}
	}

	if libutils.IsBlank(sshKeyPathRoot) {
		panic(fmt.Errorf("SSH key for root user is required by supplying mandatory flag --%s", flagSshKeyPathRoot))
	}

	if !isFileExists(sshKeyPathRoot) {
		panic(fmt.Sprintf("SSH key (for root user) could not be found: %s", sshKeyPathRoot))
	}

	if libutils.IsBlank(sshKeyPathUser) {
		panic(fmt.Errorf("SSH key (fallback) for non-root user is required by supplying mandatory flag --%s", flagSshKeyPathUser))
	}

	if !isFileExists(sshKeyPathUser) {
		panic(fmt.Sprintf("SSH key (fallback for non-root user) could not be found: %s", sshKeyPathUser))
	}

	mapSshKeyPathPerUser := make(map[string]string)
	if len(sshKeyPathPerUser) > 0 {
		if len(sshKeyPathPerUser)%2 != 0 {
			panic(fmt.Sprintf("SSH key pair supplied by flag --%s must satisfy the format: user1,path1,user2,path2", flagSshKeyPathPerUser))
		}

		for i := 0; i < len(sshKeyPathPerUser); i += 2 {
			user := sshKeyPathPerUser[i]
			keyPath := sshKeyPathPerUser[i+1]

			if strings.EqualFold(user, "root") {
				panic(fmt.Sprintf("SSH user \"root\" is not accepted to be supplied by flag --%s", flagSshKeyPathPerUser))
			}

			if !regexp.MustCompile("^[a-z][-a-z\\d_]*\\$?$").MatchString(user) {
				panic(fmt.Sprintf("SSH user \"%s\" supplied by flag --%s is malformed", user, flagSshKeyPathPerUser))
			}

			if libutils.IsBlank(keyPath) {
				panic(fmt.Sprintf("Key path for SSH user \"%s\" supplied by flag --%s is missing", user, flagSshKeyPathPerUser))
			}

			if !isFileExists(keyPath) {
				panic(fmt.Sprintf("Key path for SSH user \"%s\" supplied by flag --%s does not exists: %s", user, flagSshKeyPathPerUser, keyPath))
			}

			mapSshKeyPathPerUser[user] = keyPath
		}
	}

	sshConfigContent := "# Generated by House Keeper\n"

	bz, err := os.ReadFile(tsvInputFilePath)
	if err != nil {
		panic(errors.Wrap(err, fmt.Sprintf("failed to read %s", tsvInputFilePath)))
	}
	tsvLines := goe.NewIEnumerable(strings.Split(string(bz), "\n")...).Select(func(line string) any {
		return strings.TrimSpace(line)
	}).CastString()
	if !tsvLines.Any() {
		panic(fmt.Errorf("input TSV %s is empty", tsvInputFilePath))
	}
	hostTracker := make(map[string]bool)
	for _, line := range tsvLines.ToArray() {
		spl := strings.SplitN(
			regexReplaceContinousSpace.ReplaceAllString(strings.Replace(line, "\t", " ", -1), " "),
			" ", 3,
		)
		if len(spl) != 3 {
			panic(fmt.Sprintf("in input tsv file, each line must maintains format: %s", tsvLineFormat))
		}

		host := strings.TrimSpace(spl[0])
		hostName := strings.TrimSpace(spl[1])
		user := strings.TrimSpace(spl[2])

		var comment string

		if len(host) < 1 {
			panic(fmt.Sprintf("SSH config host must not be empty at line: %s", line))
		}
		normalizedHost := strings.ToLower(host)
		if _, found := hostTracker[normalizedHost]; found {
			panic(fmt.Sprintf("SSH config host does not unique at line: %s", line))
		}
		hostTracker[normalizedHost] = true
		if len(hostName) < 1 {
			panic(fmt.Sprintf("SSH config host name must not be empty at line: %s", line))
		}
		if len(user) < 1 {
			panic(fmt.Sprintf("SSH config user must not be empty at line: %s", line))
		} else {
			commentSymbolIdx := strings.Index(user, "#")
			if commentSymbolIdx == 0 {
				panic("comment symbol '#' could not be exists at first character")
			} else if commentSymbolIdx > 0 {
				spl = strings.Split(user, "#")
				user = strings.TrimSpace(spl[0])
				comment = strings.TrimSpace(spl[1])
			}
		}

		sshConfigContent += fmt.Sprintf(`
Host %s%s
    HostName %s
    User %s
    IdentityFile %s
`,
			host,
			libutils.ConditionalString(libutils.IsBlank(comment), "", fmt.Sprintf(" # %s", comment)),
			hostName,
			user,
			func() string {
				if strings.EqualFold(user, "root") {
					return sshKeyPathRoot
				}

				if keyPath, found := mapSshKeyPathPerUser[user]; found {
					return keyPath
				}

				return sshKeyPathUser
			}(),
		)
	}

	err = os.WriteFile(sshConfigOutputFilePath, []byte(sshConfigContent), 0o644)
	if err != nil {
		panic(errors.Wrap(err, "failed to write output SSH config file"))
	}

	fmt.Println("Output file:", sshConfigOutputFilePath)
}
